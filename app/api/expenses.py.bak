from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from sqlalchemy import extract
from typing import List
from datetime import datetime, date
from ..db.session import get_db
from ..db.models import Expense
from ..schemas.expense import ExpenseCreate, ExpenseUpdate, Expense as ExpenseSchema
from ..api.auth import get_current_admin_user

router = APIRouter()

@router.post("/", response_model=ExpenseSchema)
def create_expense(
    expense: ExpenseCreate,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_admin_user)
):
    """Create a new expense record."""
    try:
        # Create the expense with all fields
        db_expense = Expense(
            category=expense.category,
            amount=expense.amount,
            description=expense.description,
            expense_date=expense.expense_date,
            payment_method=expense.payment_method if hasattr(expense, 'payment_method') else "Cash"
        )
        
        db.add(db_expense)
        db.commit()
        db.refresh(db_expense)
        return db_expense
    except Exception as e:
        db.rollback()
        print(f"Error creating expense: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to create expense: {str(e)}"
        )

@router.get("/", response_model=List[ExpenseSchema])
def get_expenses(
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_admin_user),
    skip: int = 0,
    limit: int = 100
):
    """Get all expenses, optionally paginated."""
    expenses = db.query(Expense).order_by(Expense.expense_date.desc()).offset(skip).limit(limit).all()
    return expenses

@router.get("/date-range", response_model=List[ExpenseSchema])
def get_expenses_by_date_range(
    start_date: date,
    end_date: date,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_admin_user)
):
    """Get expenses between two dates."""
    expenses = db.query(Expense).filter(
        Expense.expense_date >= start_date,
        Expense.expense_date <= end_date
    ).order_by(Expense.expense_date.desc()).all()
    
    return expenses

@router.get("/{expense_id}", response_model=ExpenseSchema)
def get_expense(
    expense_id: int,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_admin_user)
):
    """Get a specific expense by ID."""
    expense = db.query(Expense).filter(Expense.id == expense_id).first()
    if not expense:
        raise HTTPException(status_code=404, detail="Expense not found")
    return expense

@router.put("/{expense_id}", response_model=ExpenseSchema)
def update_expense(
    expense_id: int,
    expense_update: ExpenseUpdate,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_admin_user)
):
    """Update an existing expense."""
    db_expense = db.query(Expense).filter(Expense.id == expense_id).first()
    if not db_expense:
        raise HTTPException(status_code=404, detail="Expense not found")
    
    update_data = expense_update.dict(exclude_unset=True)
    for key, value in update_data.items():
        setattr(db_expense, key, value)
    
    db.commit()
    db.refresh(db_expense)
    return db_expense

@router.delete("/{expense_id}", response_model=dict)
def delete_expense(
    expense_id: int,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_admin_user)
):
    """Delete an expense."""
    expense = db.query(Expense).filter(Expense.id == expense_id).first()
    if not expense:
        raise HTTPException(status_code=404, detail="Expense not found")
    
    db.delete(expense)
    db.commit()
    return {"success": True, "message": "Expense deleted"}

@router.get("/date-range", response_model=List[ExpenseSchema])
def get_expenses_by_date_range(
    start_date: date,
    end_date: date,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_admin_user)
):
    """Get expenses between two dates."""
    expenses = db.query(Expense).filter(
        Expense.expense_date >= start_date,
        Expense.expense_date <= end_date
    ).order_by(Expense.expense_date.desc()).all()
    
    return expenses

@router.get("/monthly/{year}/{month}", response_model=List[ExpenseSchema])
def get_monthly_expenses(
    year: int,
    month: int,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_admin_user)
):
    """Get expenses for a specific month and year."""
    if month < 1 or month > 12:
        raise HTTPException(status_code=400, detail="Month must be between 1 and 12")
    
    expenses = db.query(Expense).filter(
        extract('year', Expense.expense_date) == year,
        extract('month', Expense.expense_date) == month
    ).order_by(Expense.expense_date).all()
    
    return expenses

@router.get("/summary/{year}/{month}", response_model=dict)
def get_monthly_expense_summary(
    year: int,
    month: int,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_admin_user)
):
    """Get a summary of expenses by category for a specific month and year."""
    if month < 1 or month > 12:
        raise HTTPException(status_code=400, detail="Month must be between 1 and 12")
    
    expenses = db.query(Expense).filter(
        extract('year', Expense.expense_date) == year,
        extract('month', Expense.expense_date) == month
    ).all()
    
    # Create summary by category
    summary = {}
    total = 0
    
    for expense in expenses:
        category = expense.category
        amount = float(expense.amount)
        
        if category not in summary:
            summary[category] = 0
        
        summary[category] += amount
        total += amount
    
    return {
        "total": total,
        "categories": summary,
        "year": year,
        "month": month
    }

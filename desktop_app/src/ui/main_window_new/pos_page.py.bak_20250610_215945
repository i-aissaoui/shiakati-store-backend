"""
POS Page functionality for the Shiakati Store POS application.
"""

from PyQt5.QtWidgets import (
    QVBoxLayout, QHBoxLayout, QPushButton, QLabel, QLineEdit, 
    QTableWidget, QTableWidgetItem, QSpinBox, QMessageBox
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QFont


class POSPageMixin:
    """Mixin class for the POS page functionality."""
    
    def setup_pos_page(self):
        """Set up the Point of Sale page."""
        layout = QVBoxLayout()
        
        # Top section with search and barcode
        top_section = QHBoxLayout()
        
        # Product search
        search_layout = QVBoxLayout()
        search_label = QLabel("Product Search")
        self.product_search = QLineEdit()
        self.product_search.setPlaceholderText("Search products by name...")
        self.product_search.textChanged.connect(self.filter_product_list)
        search_layout.addWidget(search_label)
        search_layout.addWidget(self.product_search)
        
        # Product list
        self.product_list = QTableWidget()
        self.product_list.setColumnCount(4)
        self.product_list.setHorizontalHeaderLabels(["Name", "Barcode", "Price", "Stock"])
        self.product_list.verticalHeader().setVisible(False)
        self.product_list.setSelectionBehavior(QTableWidget.SelectRows)
        self.product_list.setEditTriggers(QTableWidget.NoEditTriggers)  # Disable editing
        self.product_list.itemDoubleClicked.connect(self.add_product_from_list)
        self.product_list.setMinimumHeight(300)
        self.product_list.setStyleSheet("""
            QTableWidget {
                border: 1px solid #dcdde1;
                border-radius: 4px;
                background-color: white;
                font-size: 13px;
            }
            QTableWidget::item {
                padding: 12px 8px;
                border-bottom: 1px solid #f1f2f6;
                min-height: 20px;
            }
            QHeaderView::section {
                background-color: #f1f2f6;
                padding: 12px 8px;
                border: none;
                font-weight: bold;
            }
        """)
        search_layout.addWidget(self.product_list)
        
        # Barcode scanner input
        scanner_layout = QVBoxLayout()
        scanner_label = QLabel("Barcode Scanner")
        self.barcode_input = QLineEdit()
        self.barcode_input.setPlaceholderText("Scan or enter barcode")
        self.barcode_input.returnPressed.connect(self.handle_barcode_scan)
        scanner_layout.addWidget(scanner_label)
        scanner_layout.addWidget(self.barcode_input)
        
        # Quick add quantity
        quantity_layout = QHBoxLayout()
        self.quantity_input = QSpinBox()
        self.quantity_input.setMinimum(1)
        self.quantity_input.setMaximum(999)
        self.quantity_input.setValue(1)
        # Apply consistent styling using our helper method
        self.apply_spinbox_styling(self.quantity_input)
        quantity_layout.addWidget(QLabel("Quantity:"))
        quantity_layout.addWidget(self.quantity_input)
        scanner_layout.addLayout(quantity_layout)
        
        # Add search and scanner to top section
        top_section.addLayout(search_layout, stretch=2)
        top_section.addLayout(scanner_layout, stretch=1)
        
        # Current sale table
        self.sale_table = QTableWidget()
        self.sale_table.setColumnCount(6)
        self.sale_table.setHorizontalHeaderLabels(["Product", "Barcode", "Price", "Quantity", "Total", "Actions"])
        self.sale_table.verticalHeader().setVisible(False)
        self.sale_table.setMinimumHeight(300)
        
        # Set row height to accommodate the delete button (increased height)
        self.sale_table.verticalHeader().setDefaultSectionSize(45)
        
        # Disable editing for all columns
        self.sale_table.setEditTriggers(QTableWidget.NoEditTriggers)
        # Remove the itemChanged connection since editing is disabled
        # self.sale_table.itemChanged.connect(self.handle_sale_item_change)
        
        # Improve table styling
        self.sale_table.setStyleSheet("""
            QTableWidget {
                border: 1px solid #dcdde1;
                border-radius: 4px;
                background-color: white;
                font-size: 13px;
            }
            QTableWidget::item {
                padding: 12px 8px;
                border-bottom: 1px solid #f1f2f6;
                min-height: 20px;
            }
            QTableWidget::item:selected {
                background-color: #0984e3;
                color: white;
            }
            QHeaderView::section {
                background-color: #f1f2f6;
                padding: 12px 8px;
                border: none;
                font-weight: bold;
            }
        """)

        # Sale controls
        controls_layout = QHBoxLayout()
        
        # Customer info (optional)
        customer_layout = QVBoxLayout()
        customer_label = QLabel("Customer Info (Optional)")
        self.customer_name = QLineEdit()
        self.customer_name.setPlaceholderText("Customer Name")
        self.customer_phone = QLineEdit()
        self.customer_phone.setPlaceholderText("Customer Phone")
        customer_layout.addWidget(customer_label)
        customer_layout.addWidget(self.customer_name)
        customer_layout.addWidget(self.customer_phone)
        controls_layout.addLayout(customer_layout)
        
        # Totals section
        totals_layout = QVBoxLayout()
        self.subtotal_label = QLabel("Subtotal: 0.00 DZD")
        self.total_label = QLabel("Total: 0.00 DZD")
        self.total_label.setFont(QFont("Arial", 20, QFont.Weight.Bold))
        totals_layout.addWidget(self.subtotal_label)
        totals_layout.addWidget(self.total_label)
        controls_layout.addLayout(totals_layout)
        
        # Action buttons
        buttons_layout = QVBoxLayout()
        self.clear_sale_button = QPushButton("Clear Sale")
        self.clear_sale_button.clicked.connect(self.clear_current_sale)
        self.checkout_button = QPushButton("Complete Sale")
        self.checkout_button.clicked.connect(self.handle_checkout)
        buttons_layout.addWidget(self.clear_sale_button)
        buttons_layout.addWidget(self.checkout_button)
        controls_layout.addLayout(buttons_layout)
        
        # Add all widgets to main layout
        layout.addLayout(top_section)
        layout.addWidget(self.sale_table)
        layout.addLayout(controls_layout)
        
        self.pos_page.setLayout(layout)
        
        # Load initial product list
        self.load_product_list()

    def handle_barcode_scan(self):
        """Handle barcode scanner input."""
        barcode = self.barcode_input.text().strip()
        if not barcode:
            return
            
        # Add product to sale
        self.add_product_to_sale(barcode)
            
        # Clear barcode input
        self.barcode_input.clear()

    def filter_product_list(self):
        """Filter the product list based on search text."""
        search_text = self.product_search.text().lower()
        for row in range(self.product_list.rowCount()):
            match = False
            for col in range(self.product_list.columnCount()):
                item = self.product_list.item(row, col)
                if item and search_text in item.text().lower():
                    match = True
                    break
            self.product_list.setRowHidden(row, not match)

    def load_product_list(self):
        """Load all products into the product list table."""
        try:
            inventory = self.api_client.get_inventory()
            self.product_list.setRowCount(0)
            
            for item in inventory:
                row = self.product_list.rowCount()
                self.product_list.insertRow(row)
                self.product_list.setItem(row, 0, QTableWidgetItem(item["product_name"]))
                self.product_list.setItem(row, 1, QTableWidgetItem(item["barcode"]))
                self.product_list.setItem(row, 2, QTableWidgetItem(self.format_price(item["price"])))
                self.product_list.setItem(row, 3, QTableWidgetItem(str(item["quantity"])))
                
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Failed to load products: {str(e)}")

    def add_product_from_list(self, item):
        """Add a product to the sale when double-clicked in the product list."""
        row = item.row()
        barcode = self.product_list.item(row, 1).text()
        self.add_product_to_sale(barcode)
            
    def add_product_to_sale(self, barcode: str):
        """Add a product to the current sale by barcode."""
        try:
            # Find product in the list
            for row in range(self.product_list.rowCount()):
                if self.product_list.item(row, 1).text().strip() == barcode.strip():
                    name = self.product_list.item(row, 0).text()
                    price = self.parse_price(self.product_list.item(row, 2).text())
                    stock = float(self.product_list.item(row, 3).text())  # Use float instead of int
                    quantity = float(self.quantity_input.value())  # Use float instead of int
                    if quantity <= 0:
                        QMessageBox.warning(self, "Error", "Quantity must be greater than 0")
                        return
                    if quantity > stock:
                        QMessageBox.warning(self, "Error", f"Not enough stock. Only {stock} available.")
                        return
                    
                    # Check if already in sale
                    for sale_row in range(self.sale_table.rowCount()):
                        if self.sale_table.item(sale_row, 1).text().strip() == barcode.strip():
                            # Item already in cart, update quantity
                            current_qty = float(self.sale_table.item(sale_row, 3).text())
                            new_qty = current_qty + quantity
                            
                            if new_qty > stock:
                                QMessageBox.warning(self, "Error", f"Not enough stock. Only {stock} available.")
                                return
                                
                            self.sale_table.setItem(sale_row, 3, QTableWidgetItem(f"{new_qty:.1f}"))
                            self.sale_table.setItem(sale_row, 4, QTableWidgetItem(self.format_price(price * new_qty)))
                            self.update_sale_totals()
                            return
                    
                    # Add new row to sale
                    row = self.sale_table.rowCount()
                    self.sale_table.insertRow(row)
                    self.sale_table.setItem(row, 0, QTableWidgetItem(name))
                    self.sale_table.setItem(row, 1, QTableWidgetItem(barcode))
                    self.sale_table.setItem(row, 2, QTableWidgetItem(self.format_price(price)))
                    self.sale_table.setItem(row, 3, QTableWidgetItem(f"{quantity:.1f}"))
                    self.sale_table.setItem(row, 4, QTableWidgetItem(self.format_price(price * quantity)))
                    
                    # Add remove button
                    remove_btn = QPushButton("❌")
                    remove_btn.setFixedSize(35, 35)  # Increased button size for better visibility
                    remove_btn.setStyleSheet("""
                        QPushButton {
                            font-size: 14px;
                            border: none;
                            border-radius: 17px;
                            background-color: #e74c3c;
                            color: white;
                            font-weight: bold;
                        }
                        QPushButton:hover {
                            background-color: #c0392b;
                        }
                        QPushButton:pressed {
                            background-color: #a93226;
                        }
                    """)
                    remove_btn.clicked.connect(lambda checked, r=row: self.remove_sale_item(r))
                    self.sale_table.setCellWidget(row, 5, remove_btn)
                    
                    self.update_sale_totals()
                    self.quantity_input.setValue(1)
                    return
            
            QMessageBox.warning(self, "Error", "Product not found")
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Failed to add product: {str(e)}")
            print(f"Error adding product: {str(e)}")  # Add debug logging

    def clear_current_sale(self):
        """Clear the current sale."""
        reply = QMessageBox.question(
            self, "Clear Sale",
            "Are you sure you want to clear the current sale?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            self.sale_table.setRowCount(0)
            self.update_sale_totals()
            self.customer_name.clear()
            self.customer_phone.clear()
            self.quantity_input.setValue(1)

    def remove_sale_item(self, row: int):
        """Remove an item from the current sale."""
        reply = QMessageBox.question(
            self, "Remove Item",
            "Are you sure you want to remove this item?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            self.sale_table.removeRow(row)
            self.update_sale_totals()

    def update_sale_totals(self):
        """Update the subtotal and total labels."""
        subtotal = 0.0
        for row in range(self.sale_table.rowCount()):
            total_cell = self.sale_table.item(row, 4)
            if total_cell:
                subtotal += self.parse_price(total_cell.text())
        
        # Update labels with DZD format
        self.subtotal_label.setText(f"Subtotal: {self.format_price(subtotal)}")
        self.total_label.setText(f"Total: {self.format_price(subtotal)}")  # Add tax calculation if needed

    def handle_checkout(self):
        """Process the checkout."""
        if self.sale_table.rowCount() == 0:
            QMessageBox.warning(self, "Error", "No items in cart")
            return
            
        total = self.parse_price(self.total_label.text().split(': ')[1])
        
        # Process the sale with the API client
        sale_items = []
        for row in range(self.sale_table.rowCount()):
            try:
                barcode = self.sale_table.item(row, 1).text().strip()
                quantity = float(self.sale_table.item(row, 3).text().strip())
                price = self.parse_price(self.sale_table.item(row, 2).text())
                sale_items.append({
                    "barcode": barcode,
                    "quantity": quantity,
                    "price": price
                })
            except (ValueError, AttributeError) as e:
                QMessageBox.warning(self, "Error", f"Invalid data in row {row + 1}")
                return
            
        try:
            response = self.api_client.create_sale(sale_items, total)
            
            if response is None:
                QMessageBox.warning(self, "Error", "No response from server")
                return
                
            if isinstance(response, dict):
                if response.get('id') or response.get('success'):
                    # Ask if user wants to print the ticket
                    reply = QMessageBox.question(
                        self,
                        "Sale Complete",
                        f"Sale completed successfully!\nTotal: {self.format_price(total)}\n\nWould you like to print the receipt?",
                        QMessageBox.Yes | QMessageBox.No,
                        QMessageBox.Yes
                    )
                    
                    if reply == QMessageBox.Yes:
                        # Get the complete sale details for printing
                        sale_details = self.api_client.get_sale_details(response['id'])
                        if sale_details:
                            self.print_sale_ticket(sale_details)
                    
                    # Clear the sale table
                    self.sale_table.setRowCount(0)
                    self.update_sale_totals()
                    self.load_product_list()  # Refresh product list
                    
                    # Only update stats if stats page is currently visible
                    if self.content_stack.currentIndex() == 2:
                        self.update_stats()  # Refresh statistics
                else:
                    error_msg = response.get('error', 'Unknown error')
                    QMessageBox.warning(self, "Error", f"Failed to process sale: {error_msg}")
            else:
                QMessageBox.warning(self, "Error", "Invalid response from server")
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Failed to process sale: {str(e)}")

    def print_sale_ticket(self, sale_data):
        """Print a sale ticket and open it with the default PDF viewer."""
        try:
            import os
            import sys
            import shutil
            import subprocess
            import time
            import logging
            from threading import Thread
            from reportlab.pdfgen import canvas
            from reportlab.lib.units import mm
            from reportlab.lib.pagesizes import A4
            from PyQt5.QtWidgets import QMessageBox
            
            # Set up logging for diagnostics
            log_file = os.path.join(os.path.expanduser("~"), "receipt_debug_fixed.log")
            logging.basicConfig(
                filename=log_file,
                level=logging.DEBUG,
                format="%(asctime)s - %(levelname)s - %(message)s",
                datefmt="%Y-%m-%d %H:%M:%S"
            )
            
            logging.info("===== RECEIPT CREATION STARTED (FIXED VERSION) =====")
            print("===== RECEIPT CREATION STARTED (FIXED VERSION) =====")
            
            # Get the relevant directory paths
            current_dir = os.path.dirname(os.path.abspath(__file__))
            desktop_app_dir = os.path.abspath(os.path.join(current_dir, "..", "..", ".."))
            backend_dir = os.path.dirname(desktop_app_dir)
            
            logging.info(f"Current directory: {current_dir}")
            logging.info(f"Desktop app directory: {desktop_app_dir}")
            logging.info(f"Backend root directory: {backend_dir}")
            
            # Define receipt directories
            desktop_receipt_dir = os.path.join(desktop_app_dir, "receipt")
            backend_receipt_dir = os.path.join(backend_dir, "receipt")
            
            logging.info(f"Desktop receipt directory: {desktop_receipt_dir}")
            logging.info(f"Backend receipt directory: {backend_receipt_dir}")
            
            # Create receipt directories if they don't exist
            for receipt_dir in [desktop_receipt_dir, backend_receipt_dir]:
                if not os.path.exists(receipt_dir):
                    try:
                        os.makedirs(receipt_dir)
                        logging.info(f"Created directory: {receipt_dir}")
                    except Exception as e:
                        logging.error(f"Error creating directory {receipt_dir}: {e}")
            
            # Define receipt filename and paths
            receipt_filename = f"Sale-{sale_data['id']}.pdf"
            backend_path = os.path.join(backend_receipt_dir, receipt_filename)
            desktop_path = os.path.join(desktop_receipt_dir, receipt_filename)
            
            logging.info(f"Backend receipt path: {backend_path}")
            logging.info(f"Desktop receipt path: {desktop_path}")
            
            try:
                # Create PDF with reportlab (more reliable than Qt's PDF generation)
                logging.info("Creating PDF with reportlab...")
                
                # Make both directories again just to be sure
                os.makedirs(os.path.dirname(backend_path), exist_ok=True)
                os.makedirs(os.path.dirname(desktop_path), exist_ok=True)
                
                # Create the canvas for drawing
                c = canvas.Canvas(backend_path, pagesize=(80 * mm, 200 * mm))
                c.setTitle(f"Sale-{sale_data['id']}")
                
                # Set initial position
                y_position = 190 * mm  # Start from top
                line_height = 5 * mm
                
                # Draw header
                c.setFont("Helvetica-Bold", 12)
                c.drawCentredString(40 * mm, y_position, "Shiakati شياكتي")
                y_position -= line_height * 1.5
                
                # Draw date and sale number
                c.setFont("Helvetica", 8)
                date_str = sale_data.get('sale_time', 'Unknown Date')
                if isinstance(date_str, str) and 'T' in date_str:
                    # Format ISO date string
                    from datetime import datetime
                    try:
                        date_obj = datetime.fromisoformat(date_str.replace('Z', '+00:00'))
                        date_str = date_obj.strftime('%Y-%m-%d %H:%M')
                    except:
                        pass
                
                c.drawCentredString(40 * mm, y_position, f"Date: {date_str}")
                y_position -= line_height
                
                c.drawCentredString(40 * mm, y_position, f"Sale: {sale_data['id']}")
                y_position -= line_height * 2
                
                # Draw separator line
                c.line(5 * mm, y_position, 75 * mm, y_position)
                y_position -= line_height
                
                # Draw column headers
                c.setFont("Helvetica-Bold", 7)
                c.drawString(5 * mm, y_position, "Item")
                c.drawRightString(55 * mm, y_position, "Qty")
                c.drawRightString(65 * mm, y_position, "Price")
                c.drawRightString(75 * mm, y_position, "Total")
                y_position -= line_height
                
                # Draw separator line
                c.line(5 * mm, y_position, 75 * mm, y_position)
                y_position -= line_height
                
                # Draw items
                c.setFont("Helvetica", 7)
                total_amount = 0
                
                # Helper function to handle long product names
                def draw_wrapped_text(text, x, y, width, line_height):
                    from reportlab.lib.utils import simpleSplit
                    chunks = simpleSplit(text, "Helvetica", 7, width)
                    for i, chunk in enumerate(chunks):
                        c.drawString(x, y - i * line_height * 0.8, chunk)
                    return len(chunks)
                
                for item in sale_data.get("items", []):
                    product_name = item.get("product_name", "Unknown Product")
                    quantity = float(item.get("quantity", 1))
                    price = float(item.get("price", 0))
                    total = price * quantity
                    total_amount += total
                    
                    # Draw product name (possibly wrapping to multiple lines)
                    lines = draw_wrapped_text(product_name, 5 * mm, y_position, 40 * mm, line_height)
                    
                    # Draw quantity, price, and total
                    c.drawRightString(55 * mm, y_position, f"{int(quantity)}")
                    c.drawRightString(65 * mm, y_position, f"{price:.2f}")
                    c.drawRightString(75 * mm, y_position, f"{total:.2f}")
                    
                    # Move position down based on number of text lines
                    y_position -= line_height * max(lines, 1) + line_height * 0.2
                
                # Draw separator line
                c.line(5 * mm, y_position, 75 * mm, y_position)
                y_position -= line_height * 1.5
                
                # Draw total
                c.setFont("Helvetica-Bold", 10)
                c.drawRightString(40 * mm, y_position, "Total:")
                c.drawRightString(75 * mm, y_position, f"{total_amount:.2f} DZD")
                y_position -= line_height * 3
                
                # Draw footer
                c.setFont("Helvetica", 8)
                c.drawCentredString(40 * mm, y_position, "Thank you")
                
                # Save the PDF
                c.save()
                
                # Verify the file exists and has content
                if os.path.exists(backend_path):
                    size = os.path.getsize(backend_path)
                    logging.info(f"PDF created successfully: {backend_path} ({size} bytes)")
                    print(f"PDF created successfully: {backend_path} ({size} bytes)")
                else:
                    logging.error(f"PDF file not found after creation: {backend_path}")
                    print(f"PDF file not found after creation: {backend_path}")
                    raise FileNotFoundError(f"PDF file not found after creation: {backend_path}")
                
                # Copy the file to the desktop receipt directory
                try:
                    shutil.copy2(backend_path, desktop_path)
                    if os.path.exists(desktop_path):
                        size = os.path.getsize(desktop_path)
                        logging.info(f"PDF copied to desktop app directory: {desktop_path} ({size} bytes)")
                        print(f"PDF copied to desktop app directory: {desktop_path} ({size} bytes)")
                    else:
                        logging.error(f"Copy exists but file not found: {desktop_path}")
                        print(f"Copy exists but file not found: {desktop_path}")
                except Exception as e:
                    logging.error(f"Error copying to desktop directory: {e}")
                    print(f"Error copying to desktop directory: {e}")
                    # Continue anyway, we have the primary copy
                
                # Show success message
                QMessageBox.information(
                    self,
                    "Success",
                    f"Receipt has been saved successfully."
                )
                
                # Open the PDF in a separate thread
                def open_pdf_thread():
                    try:
                        # Small delay to ensure PDF is fully written
                        time.sleep(1.0)
                        
                        # Verify the file exists
                        receipt_path = None
                        for path in [backend_path, desktop_path]:
                            if os.path.exists(path) and os.path.getsize(path) > 0:
                                receipt_path = path
                                logging.info(f"Using receipt path: {receipt_path}")
                                break
                                
                        if not receipt_path:
                            logging.error("No valid receipt file found to open")
                            raise FileNotFoundError("No valid receipt file found to open")
                            
                        logging.info(f"Opening receipt: {receipt_path}")
                        
                        # Platform-specific opening
                        if sys.platform == 'win32':
                            os.startfile(receipt_path)
                            logging.info("Used os.startfile on Windows")
                        elif sys.platform == 'darwin':  # macOS
                            subprocess.call(['open', receipt_path])
                            logging.info("Used 'open' command on macOS")
                        else:  # Linux
                            # Try different viewers
                            viewers = ['xdg-open', 'evince', 'okular', 'firefox', 'google-chrome']
                            opened = False
                            
                            for viewer in viewers:
                                try:
                                    logging.info(f"Trying to open with {viewer}...")
                                    result = subprocess.call([viewer, receipt_path])
                                    if result == 0:
                                        logging.info(f"Successfully opened with {viewer}")
                                        opened = True
                                        break
                                except Exception as e:
                                    logging.info(f"Error with {viewer}: {e}")
                            
                            if not opened:
                                # Fall back to opening the directory
                                directory = os.path.dirname(receipt_path)
                                logging.info(f"Opening directory: {directory}")
                                subprocess.call(['xdg-open', directory])
                                
                                # Show message about the location
                                QMessageBox.information(
                                    self,
                                    "Receipt Location",
                                    f"The receipt has been saved to:\n{receipt_path}\n\nOpening the folder containing the receipt."
                                )
                                
                    except Exception as e:
                        logging.error(f"Error in open_pdf_thread: {e}")
                        import traceback
                        logging.error(traceback.format_exc())
                
                # Start the thread to open the PDF
                Thread(target=open_pdf_thread).start()
                
                logging.info("===== RECEIPT CREATION COMPLETED (FIXED VERSION) =====")
                return True
            except Exception as e:
                logging.error(f"Error creating PDF: {e}")
                logging.error(traceback.format_exc())
                print(f"Error creating PDF: {e}")
                
                # Show error message
                QMessageBox.warning(
                    self,
                    "Error",
                    f"Failed to create receipt PDF: {str(e)}"
                )
                return False
        except Exception as e:
            logging.error(f"Unhandled error in print_sale_ticket: {e}")
            import traceback
            logging.error(traceback.format_exc())
            print(f"Unhandled error in print_sale_ticket: {e}")
            
            # Show error message
            QMessageBox.warning(
                self,
                "Error",
                f"Failed to print receipt: {str(e)}"
            )
            return False